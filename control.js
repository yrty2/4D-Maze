const marks=[];
var moveSeed=-1;
var hojo=false;
var rotortime=17;
var rotor=[];
function frame(){
    if(mezirusitime>0){
        mezirusitime--;
    }
    if(key=="Enter"){
        if(moveSeed==-1){
            const v=clifford.rotate4D([0,0,1,0],clifford.inverse(z));
            const mid=map.findIndex(e=>e.michi && vec.length(vec.dec(vec.dec(e.ijkh,player.ijkh),v))<0.1);
            if(mid!=-1){
            moveSeed=map[mid].seed;
            player.toijkh=map[mid].ijkh;
            }
        }
    }
    if(moveSeed!=-1){
        //この辺の平行移動関数を直せばなんとかなるかも
        //周りに壁がある用に見えないようにするために、(相対座標の)w=0のみ表示するとか考えてるがなんかミスってる。
        //思ったより試行錯誤が必要。
        const mid=map.findIndex(e=>e.seed==moveSeed);
        if(mid!=-1){
            var m=map[mid];
            var f;
            if(gamemode=="3D"){
                f=[1,1,1,0];
            }else{
                f=[1,1,1,1];
            }
            const d=vec.dec(m.position,vec.dec(player.position,vec.prod(f,boxsize/2)));
            if(vec.length(d)<0.5){
                player.position=vec.sum(m.position,vec.prod(f,boxsize/2)).slice();
                player.ijkh=m.ijkh;
                moveSeed=-1;
                if(kagi.list.findIndex(e=>e.join()==m.ijkh.join())!=-1){
                    getKey();
                }
                //踏破判定
                if(m.ijkh.join()==goalijkh.join()){
                    if(kagi.value==0){
                        youwingoal();
                    }
                }
            }
            player.position=vec.sum(player.position,vec.prod(d,14/(2*fps)));
        }
    }
    if(!win && rotor.length>0){
        const r=rotor[0];
        if(r.mode==3 || r.mode==4){
            view4D=3.5;
        }
        if(vec.length(vec.dec(r.res,z))>0.1){
            z=clifford.product4D(z,clifford.rot(4,r.mode,60*r.value*Math.PI/(2*rotortime*fps)));
        }else{
            z=r.res.slice();
            rotor=deleteIndex(rotor,0).slice();
            view4D=2.5;
        }
        r.timer++;
    }
    camera.position=vec.prod(player.position,-1/2);
}
function keycontrol(){
    if(key=="KeyW"){
        if(win){
            z=clifford.product4D(z,clifford.rot(4,1,Math.PI/40));
        }else{
            toz=clifford.product4D(toz,clifford.rot(4,1,Math.PI/2));
        rotor.push({
            res:toz,
            seed:Math.random(),
            mode:1,
            value:1,
            timer:0
        });
        }
    }
    if(key=="KeyA"){
        if(win){
            z=clifford.product4D(z,clifford.rot(4,2,-Math.PI/40));
        }else{
            toz=clifford.product4D(toz,clifford.rot(4,2,-Math.PI/2));
        rotor.push({
            res:toz,
            seed:Math.random(),
            mode:2,
            value:-1,
            timer:0
        });
            }
    }
    if(key=="KeyS"){
        if(win){
            z=clifford.product4D(z,clifford.rot(4,1,-Math.PI/40));
        }else{
            toz=clifford.product4D(toz,clifford.rot(4,1,-Math.PI/2));
        rotor.push({
            res:toz,
            seed:Math.random(),
            mode:1,
            value:-1,
            timer:0
        });
            }
    }
    if(key=="KeyD"){
        if(win){
            z=clifford.product4D(z,clifford.rot(4,2,Math.PI/40));
        }else{
            toz=clifford.product4D(toz,clifford.rot(4,2,Math.PI/2));
        rotor.push({
            res:toz,
            seed:Math.random(),
            mode:2,
            value:1,
            timer:0
        });
            }
    }
    if(key=="KeyQ"){
        if(win){
            z=clifford.product4D(z,clifford.rot(4,5,Math.PI/40));
        }else{
            toz=clifford.product4D(toz,clifford.rot(4,5,Math.PI/2));
        rotor.push({
            res:toz,
            seed:Math.random(),
            mode:5,
            value:1,
            timer:0
        });
            }
    }
    if(key=="KeyE"){
        if(win){
            z=clifford.product4D(z,clifford.rot(4,5,-Math.PI/40));
        }else{
            toz=clifford.product4D(toz,clifford.rot(4,5,-Math.PI/2));
        rotor.push({
            res:toz,
            seed:Math.random(),
            mode:5,
            value:-1,
            timer:0
        });
            }
    }
    if(key=="ArrowLeft"){
        if(win){
            z=clifford.product4D(z,clifford.rot(4,3,Math.PI/40));
        }else{
            toz=clifford.product4D(toz,clifford.rot(4,3,Math.PI/2));
        rotor.push({
            res:toz,
            seed:Math.random(),
            mode:3,
            value:1,
            timer:0
        });
            }
    }
    if(key=="ArrowRight"){
        if(win){
            z=clifford.product4D(z,clifford.rot(4,3,-Math.PI/40));
        }else{
            toz=clifford.product4D(toz,clifford.rot(4,3,-Math.PI/2));
        rotor.push({
            res:toz,
            seed:Math.random(),
            mode:3,
            value:-1,
            timer:0
        });
            }
    }
    if(key=="ArrowUp"){
        if(win){
            z=clifford.product4D(z,clifford.rot(4,4,Math.PI/40));
        }else{
            toz=clifford.product4D(toz,clifford.rot(4,4,Math.PI/2));
        rotor.push({
            res:toz,
            seed:Math.random(),
            mode:4,
            value:1,
            timer:0
        });
            }
    }
    if(key=="ArrowDown"){
        if(win){
            z=clifford.product4D(z,clifford.rot(4,4,-Math.PI/40));
        }else{
            toz=clifford.product4D(toz,clifford.rot(4,4,-Math.PI/2));
        rotor.push({
            res:toz,
            seed:Math.random(),
            mode:4,
            value:-1,
            timer:0
        });
            }
    }
    if(key=="KeyZ"){
        if(win){
            z=clifford.product4D(z,clifford.rot(4,0,Math.PI/40));
        }else{
            toz=clifford.product4D(toz,clifford.rot(4,0,Math.PI/2));
        rotor.push({
            res:toz,
            seed:Math.random(),
            mode:0,
            value:1,
            timer:0
        });
            }
    }
    if(key=="KeyX"){
        if(win){
            z=clifford.product4D(z,clifford.rot(4,0,-Math.PI/40));
        }else{
            toz=clifford.product4D(toz,clifford.rot(4,0,-Math.PI/2));
        rotor.push({
            res:toz,
            seed:Math.random(),
            mode:0,
            value:-1,
            timer:0
        });
            }
    }
    if(key=="KeyT"){
        if(mazirushiavailable && mezirusitime==0){
            mezirushi();
            mezirusitime=300;
        }
    }
    if(key=="KeyI"){
        if(hojoavailable){
        hojo=!hojo;
        }
    }
}
function mezirushi(){
    if(marks.findIndex(e=>e.join()==player.toijkh.join())==-1){
    marks.push(player.toijkh);
    const s=2;
    for(let i=0; i<=1; ++i){
        for(let j=0; j<=1; ++j){
            for(let k=0; k<=1; ++k){
                for(let h=0; h<=1; ++h){
    hypercube(vec.sum(vec.prod(player.toijkh,boxsize),[i*(boxsize-s),j*(boxsize-s),k*(boxsize-s),h*(boxsize-s)]),s,[0,1,1,0.5]);
                }
            }
        }
    }
    generateInstance();
        }
}